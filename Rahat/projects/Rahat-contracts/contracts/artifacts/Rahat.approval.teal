#pragma version 10

// This TEAL was generated by TEALScript v0.92.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createProject(uint64,(string,address,address[]))void
*abi_route_createProject:
	// _project: (string,address,address[])
	txna ApplicationArgs 2

	// _assetId: uint64
	txna ApplicationArgs 1
	btoi

	// execute createProject(uint64,(string,address,address[]))void
	callsub createProject
	int 1
	return

// createProject(_assetId:AssetID, _project: projectType): void
//
// A method to create a project
// @param _id Unique address of project
// @param _project Project type
// @returns Void
createProject:
	proto 2 0

	// contracts\Rahat.algo.ts:25
	// this.project(_assetId).value = _project
	frame_dig -1 // _assetId: AssetID
	itob
	dup
	box_del
	pop
	frame_dig -2 // _project: projectType
	box_put
	retsub

// addAdminToProject(address,uint64)void
*abi_route_addAdminToProject:
	// _assetId: uint64
	txna ApplicationArgs 2
	btoi

	// _address: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (_address) for addAdminToProject must be a address
	assert

	// execute addAdminToProject(address,uint64)void
	callsub addAdminToProject
	int 1
	return

// addAdminToProject(_address: Address, _assetId: AssetID): void
//
// A method to assign beneficiary to projects
// @param _address Address of admin to be assigned
// @returns The result of the operation
addAdminToProject:
	proto 2 0

	// contracts\Rahat.algo.ts:34
	// assert(this.project(_assetId).value.superAdmin === this.txn.sender, "Only super admin can assign admin")
	frame_dig -2 // _assetId: AssetID
	itob
	box_get

	// box value does not exist: this.project(_assetId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 2 32
	txn Sender
	==

	// Only super admin can assign admin
	assert

	// contracts\Rahat.algo.ts:35
	// this.project(_assetId).value.admins = [_address]
	frame_dig -2 // _assetId: AssetID
	itob
	box_get

	// box value does not exist: this.project(_assetId).value
	assert
	store 255 // full array
	int 34
	dup
	store 251 // element head offset
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup
	store 254 // element start
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 32 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	store 253 // element length
	load 255 // full array
	int 0
	load 254 // element start
	substring3
	frame_dig -1 // _address: Address
	dup
	len
	int 32
	/
	itob
	extract 6 2
	swap
	concat
	dup
	store 252 // new element
	load 255 // full array
	load 254 // element start
	load 253 // element length
	+ // get end of Element
	load 255 // full array
	len
	substring3
	concat
	concat
	store 255 // full array
	callsub *get_length_difference
	load 255 // full array
	frame_dig -2 // _assetId: AssetID
	itob
	dup
	box_del
	pop
	swap
	box_put
	retsub

// getProject(uint64)(string,address,address[])
*abi_route_getProject:
	// The ABI return prefix
	byte 0x151f7c75

	// _assetId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getProject(uint64)(string,address,address[])
	callsub getProject
	concat
	log
	int 1
	return

// getProject(_assetId: AssetID): projectType
//
// A method to get admin
// @param _assetId Address of admin to be assigned
// @returns The result of the operation
getProject:
	proto 1 1

	// contracts\Rahat.algo.ts:44
	// return this.project(_assetId).value;
	frame_dig -1 // _assetId: AssetID
	itob
	box_get

	// box value does not exist: this.project(_assetId).value
	assert
	retsub

// createAnAsset(string,string)uint64
*abi_route_createAnAsset:
	// The ABI return prefix
	byte 0x151f7c75

	// asaSymbol: string
	txna ApplicationArgs 2
	extract 2 0

	// asaName: string
	txna ApplicationArgs 1
	extract 2 0

	// execute createAnAsset(string,string)uint64
	callsub createAnAsset
	itob
	concat
	log
	int 1
	return

// createAnAsset(asaName: string, asaSymbol: string): AssetID
//
// A method to create token
// @param asaName Address of beneficiary to send token
// @param asaSymbol Address of beneficiary to send token
// @param _name Address of beneficiary to send token
// @returns Asset (token)
createAnAsset:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\Rahat.algo.ts:55
	// asset = sendAssetCreation({
	//       configAssetTotal: 1_000_000_000_000_000,
	//       configAssetFreeze: this.app.address,
	//       configAssetName: asaName,
	//       configAssetUnitName: asaSymbol,
	//       configAssetClawback: this.app.address
	//     })
	itxn_begin
	int acfg
	itxn_field TypeEnum

	// contracts\Rahat.algo.ts:56
	// configAssetTotal: 1_000_000_000_000_000
	int 1_000_000_000_000_000
	itxn_field ConfigAssetTotal

	// contracts\Rahat.algo.ts:57
	// configAssetFreeze: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetFreeze

	// contracts\Rahat.algo.ts:58
	// configAssetName: asaName
	frame_dig -1 // asaName: string
	itxn_field ConfigAssetName

	// contracts\Rahat.algo.ts:59
	// configAssetUnitName: asaSymbol
	frame_dig -2 // asaSymbol: string
	itxn_field ConfigAssetUnitName

	// contracts\Rahat.algo.ts:60
	// configAssetClawback: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetClawback

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID
	frame_bury 0 // asset: uint64

	// contracts\Rahat.algo.ts:62
	// return asset;
	frame_dig 0 // asset: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

// sendTokenToBeneficiary(address,uint64,uint64)void
*abi_route_sendTokenToBeneficiary:
	// assetId: uint64
	txna ApplicationArgs 3
	btoi

	// amount: uint64
	txna ApplicationArgs 2
	btoi

	// benAddress: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (benAddress) for sendTokenToBeneficiary must be a address
	assert

	// execute sendTokenToBeneficiary(address,uint64,uint64)void
	callsub sendTokenToBeneficiary
	int 1
	return

// sendTokenToBeneficiary(benAddress: Address, amount: uint64, assetId: AssetID): void
//
// A method to send tokens to beneficiary
// @param benAddress Address of beneficiary to send token
// @param amount Amount of token to send
// @param assetId: AssetID of token to be sent
sendTokenToBeneficiary:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts\Rahat.algo.ts:74
	// projectAdmins = this.project(assetId).value.admins
	frame_dig -3 // assetId: AssetID
	itob
	frame_bury 0 // storage key//projectAdmins

	// contracts\Rahat.algo.ts:75
	// isAdmin = this.checkAdminRecursive(projectAdmins, this.txn.sender, 0)
	int 0
	txn Sender
	frame_dig 0 // storage key//projectAdmins
	box_get

	// box value does not exist: this.project(assetId).value
	assert
	store 255 // full array
	int 34
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 32 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	callsub checkAdminRecursive
	frame_bury 1 // isAdmin: bool

	// contracts\Rahat.algo.ts:76
	// assert(isAdmin, "Not an admin")
	frame_dig 1 // isAdmin: bool

	// Not an admin
	assert

	// contracts\Rahat.algo.ts:79
	// sendAssetTransfer({
	//       xferAsset: assetId,
	//       assetReceiver: benAddress,
	//       assetAmount: amount
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts\Rahat.algo.ts:80
	// xferAsset: assetId
	frame_dig -3 // assetId: AssetID
	itxn_field XferAsset

	// contracts\Rahat.algo.ts:81
	// assetReceiver: benAddress
	frame_dig -1 // benAddress: Address
	itxn_field AssetReceiver

	// contracts\Rahat.algo.ts:82
	// assetAmount: amount
	frame_dig -2 // amount: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\Rahat.algo.ts:86
	// sendAssetFreeze({
	//       freezeAsset: assetId,
	//       freezeAssetAccount: benAddress,
	//       freezeAssetFrozen: true,
	//     })
	itxn_begin
	int afrz
	itxn_field TypeEnum

	// contracts\Rahat.algo.ts:87
	// freezeAsset: assetId
	frame_dig -3 // assetId: AssetID
	itxn_field FreezeAsset

	// contracts\Rahat.algo.ts:88
	// freezeAssetAccount: benAddress
	frame_dig -1 // benAddress: Address
	itxn_field FreezeAssetAccount

	// contracts\Rahat.algo.ts:89
	// freezeAssetFrozen: true
	int 1
	itxn_field FreezeAssetFrozen

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// checkAdminRecursive(address[],address,uint64)bool
*abi_route_checkAdminRecursive:
	// The ABI return prefix
	byte 0x151f7c75

	// index: uint64
	txna ApplicationArgs 3
	btoi

	// address: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 1 (address) for checkAdminRecursive must be a address
	assert

	// admins: address[]
	txna ApplicationArgs 1
	extract 2 0

	// execute checkAdminRecursive(address[],address,uint64)bool
	callsub checkAdminRecursive
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// checkAdminRecursive(admins: Address[], address: Address, index: uint64): boolean
checkAdminRecursive:
	proto 3 1

	// *if0_condition
	// contracts\Rahat.algo.ts:94
	// index >= admins.length
	frame_dig -3 // index: uint64
	frame_dig -1 // admins: Address[]
	len
	int 32
	/
	>=
	bz *if0_end

	// *if0_consequent
	// contracts\Rahat.algo.ts:95
	// return false;
	int 0
	retsub

*if0_end:
	// *if1_condition
	// contracts\Rahat.algo.ts:97
	// admins[index] == address
	frame_dig -1 // admins: Address[]
	store 255 // full array
	int 0 // initial offset
	frame_dig -3 // index: uint64
	int 32
	* // acc * typeLength
	+
	load 255 // full array
	swap
	int 32
	extract3
	frame_dig -2 // address: Address
	==
	bz *if1_end

	// *if1_consequent
	// contracts\Rahat.algo.ts:98
	// return true;
	int 1
	retsub

*if1_end:
	// contracts\Rahat.algo.ts:100
	// return this.checkAdminRecursive(admins, address, index + 1);
	frame_dig -3 // index: uint64
	int 1
	+
	frame_dig -2 // address: Address
	frame_dig -1 // admins: Address[]
	callsub checkAdminRecursive
	retsub

// freezeBeneficiaryAsset(address,uint64)void
*abi_route_freezeBeneficiaryAsset:
	// assetId: uint64
	txna ApplicationArgs 2
	btoi

	// benAddress: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (benAddress) for freezeBeneficiaryAsset must be a address
	assert

	// execute freezeBeneficiaryAsset(address,uint64)void
	callsub freezeBeneficiaryAsset
	int 1
	return

// freezeBeneficiaryAsset(benAddress: Address, assetId: AssetID): void
//
// A method to unfreeze token
// @param benAddress Address of beneficiary to unfreeze asset
freezeBeneficiaryAsset:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts\Rahat.algo.ts:109
	// projectAdmins = this.project(assetId).value.admins
	frame_dig -2 // assetId: AssetID
	itob
	frame_bury 0 // storage key//projectAdmins

	// contracts\Rahat.algo.ts:110
	// isAdmin = this.checkAdminRecursive(projectAdmins, this.txn.sender, 0)
	int 0
	txn Sender
	frame_dig 0 // storage key//projectAdmins
	box_get

	// box value does not exist: this.project(assetId).value
	assert
	store 255 // full array
	int 34
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 32 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	callsub checkAdminRecursive
	frame_bury 1 // isAdmin: bool

	// contracts\Rahat.algo.ts:111
	// assert(isAdmin, "Not an admin")
	frame_dig 1 // isAdmin: bool

	// Not an admin
	assert

	// contracts\Rahat.algo.ts:113
	// sendAssetFreeze({
	//       freezeAsset: assetId,
	//       freezeAssetAccount: benAddress,
	//       freezeAssetFrozen: true,
	//     })
	itxn_begin
	int afrz
	itxn_field TypeEnum

	// contracts\Rahat.algo.ts:114
	// freezeAsset: assetId
	frame_dig -2 // assetId: AssetID
	itxn_field FreezeAsset

	// contracts\Rahat.algo.ts:115
	// freezeAssetAccount: benAddress
	frame_dig -1 // benAddress: Address
	itxn_field FreezeAssetAccount

	// contracts\Rahat.algo.ts:116
	// freezeAssetFrozen: true
	int 1
	itxn_field FreezeAssetFrozen

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// unfreezeBeneficiaryAsset(address,uint64)void
*abi_route_unfreezeBeneficiaryAsset:
	// assetId: uint64
	txna ApplicationArgs 2
	btoi

	// benAddress: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (benAddress) for unfreezeBeneficiaryAsset must be a address
	assert

	// execute unfreezeBeneficiaryAsset(address,uint64)void
	callsub unfreezeBeneficiaryAsset
	int 1
	return

// unfreezeBeneficiaryAsset(benAddress: Address, assetId: AssetID): void
//
// A method to unfreeze token
// @param benAddress Address of beneficiary to unfreeze asset
unfreezeBeneficiaryAsset:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts\Rahat.algo.ts:126
	// projectAdmins = this.project(assetId).value.admins
	frame_dig -2 // assetId: AssetID
	itob
	frame_bury 0 // storage key//projectAdmins

	// contracts\Rahat.algo.ts:127
	// isAdmin = this.checkAdminRecursive(projectAdmins, this.txn.sender, 0)
	int 0
	txn Sender
	frame_dig 0 // storage key//projectAdmins
	box_get

	// box value does not exist: this.project(assetId).value
	assert
	store 255 // full array
	int 34
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 32 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	callsub checkAdminRecursive
	frame_bury 1 // isAdmin: bool

	// contracts\Rahat.algo.ts:128
	// assert(isAdmin, "Not an admin")
	frame_dig 1 // isAdmin: bool

	// Not an admin
	assert

	// contracts\Rahat.algo.ts:130
	// sendAssetFreeze({
	//       freezeAsset: assetId,
	//       freezeAssetAccount: benAddress,
	//       freezeAssetFrozen: false,
	//     })
	itxn_begin
	int afrz
	itxn_field TypeEnum

	// contracts\Rahat.algo.ts:131
	// freezeAsset: assetId
	frame_dig -2 // assetId: AssetID
	itxn_field FreezeAsset

	// contracts\Rahat.algo.ts:132
	// freezeAssetAccount: benAddress
	frame_dig -1 // benAddress: Address
	itxn_field FreezeAssetAccount

	// contracts\Rahat.algo.ts:133
	// freezeAssetFrozen: false
	int 0
	itxn_field FreezeAssetFrozen

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// sendTokenToVendor(address,uint64,uint64)void
*abi_route_sendTokenToVendor:
	// assetId: uint64
	txna ApplicationArgs 3
	btoi

	// amount: uint64
	txna ApplicationArgs 2
	btoi

	// venderAddress: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (venderAddress) for sendTokenToVendor must be a address
	assert

	// execute sendTokenToVendor(address,uint64,uint64)void
	callsub sendTokenToVendor
	int 1
	return

// sendTokenToVendor(venderAddress: Address, amount: uint64, assetId: AssetID): void
//
// A method to send tokens to vendors
// @param venderAddress Address of vendor to receive tokens
// @param amount Amount of token to send to vendor
sendTokenToVendor:
	proto 3 0

	// contracts\Rahat.algo.ts:143
	// sendAssetTransfer({
	//       sender: this.txn.sender,
	//       xferAsset: assetId,
	//       assetReceiver: venderAddress,
	//       assetAmount: amount,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts\Rahat.algo.ts:144
	// sender: this.txn.sender
	txn Sender
	itxn_field Sender

	// contracts\Rahat.algo.ts:145
	// xferAsset: assetId
	frame_dig -3 // assetId: AssetID
	itxn_field XferAsset

	// contracts\Rahat.algo.ts:146
	// assetReceiver: venderAddress
	frame_dig -1 // venderAddress: Address
	itxn_field AssetReceiver

	// contracts\Rahat.algo.ts:147
	// assetAmount: amount
	frame_dig -2 // amount: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// clawbackBeneficiaryAsset(address,uint64,uint64)void
*abi_route_clawbackBeneficiaryAsset:
	// amount: uint64
	txna ApplicationArgs 3
	btoi

	// assetId: uint64
	txna ApplicationArgs 2
	btoi

	// benAddress: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (benAddress) for clawbackBeneficiaryAsset must be a address
	assert

	// execute clawbackBeneficiaryAsset(address,uint64,uint64)void
	callsub clawbackBeneficiaryAsset
	int 1
	return

// clawbackBeneficiaryAsset(benAddress: Address, assetId: AssetID, amount: uint64): void
//
// A method to clawback asset
// @param benAddress Address of beneficiary to be clawbacked
// @param assetId Asset id of asset
// @param amount Amount, will be replace when box-issue is fixed
clawbackBeneficiaryAsset:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts\Rahat.algo.ts:159
	// projectAdmins = this.project(assetId).value.admins
	frame_dig -2 // assetId: AssetID
	itob
	frame_bury 0 // storage key//projectAdmins

	// contracts\Rahat.algo.ts:160
	// isAdmin = this.checkAdminRecursive(projectAdmins, this.txn.sender, 0)
	int 0
	txn Sender
	frame_dig 0 // storage key//projectAdmins
	box_get

	// box value does not exist: this.project(assetId).value
	assert
	store 255 // full array
	int 34
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 32 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	callsub checkAdminRecursive
	frame_bury 1 // isAdmin: bool

	// contracts\Rahat.algo.ts:161
	// assert(isAdmin, "Not an admin")
	frame_dig 1 // isAdmin: bool

	// Not an admin
	assert

	// contracts\Rahat.algo.ts:164
	// this.unfreezeBeneficiaryAsset(benAddress, assetId)
	frame_dig -2 // assetId: AssetID
	frame_dig -1 // benAddress: Address
	callsub unfreezeBeneficiaryAsset

	// contracts\Rahat.algo.ts:167
	// sendAssetTransfer({
	//       xferAsset: assetId,
	//       assetSender: benAddress,
	//       assetReceiver: this.app.address,
	//       assetAmount: amount,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts\Rahat.algo.ts:168
	// xferAsset: assetId
	frame_dig -2 // assetId: AssetID
	itxn_field XferAsset

	// contracts\Rahat.algo.ts:169
	// assetSender: benAddress
	frame_dig -1 // benAddress: Address
	itxn_field AssetSender

	// contracts\Rahat.algo.ts:170
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts\Rahat.algo.ts:171
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

*abi_route_createApplication:
	int 1
	return

*create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "createProject(uint64,(string,address,address[]))void"
	method "addAdminToProject(address,uint64)void"
	method "getProject(uint64)(string,address,address[])"
	method "createAnAsset(string,string)uint64"
	method "sendTokenToBeneficiary(address,uint64,uint64)void"
	method "checkAdminRecursive(address[],address,uint64)bool"
	method "freezeBeneficiaryAsset(address,uint64)void"
	method "unfreezeBeneficiaryAsset(address,uint64)void"
	method "sendTokenToVendor(address,uint64,uint64)void"
	method "clawbackBeneficiaryAsset(address,uint64,uint64)void"
	txna ApplicationArgs 0
	match *abi_route_createProject *abi_route_addAdminToProject *abi_route_getProject *abi_route_createAnAsset *abi_route_sendTokenToBeneficiary *abi_route_checkAdminRecursive *abi_route_freezeBeneficiaryAsset *abi_route_unfreezeBeneficiaryAsset *abi_route_sendTokenToVendor *abi_route_clawbackBeneficiaryAsset

	// this contract does not implement the given ABI method for call NoOp
	err

*get_length_difference:
	load 252 // new element
	len // length of new element
	load 253 // element length
	<
	bnz *swapped_difference
	load 252 // new element
	len // length of new element
	load 253 // element length
	int 1
	store 249 // subtract head difference
	b *get_difference

*swapped_difference:
	load 253 // element length
	load 252 // new element
	len // length of new element
	int 0
	store 249 // subtract head difference

*get_difference:
	- // get length difference
	store 250 // length difference
	retsub